use std::collections::HashMap;

use aws_config::BehaviorVersion;
use aws_sdk_secretsmanager::{config::Region, Client};
use fractic_server_error::{CriticalError, ServerError};

use crate::constants::{SECRETS_ID, SECRETS_REGION};

/// Fetch a subset of secrets from AWS Secrets Manager.
///
/// The AWS secret is expected to be a JSON object that maps secret keys
/// (`&str`) to their String values.  Two environment variables must be set at
/// runtime so the loader knows **where** to look for the JSON blob:
///
///  • `SECRETS_REGION` – the AWS region, e.g. `"eu-central-1"`
///  • `SECRETS_ID`     – the name / ARN of the secret in Secrets Manager
///
/// The function will retrieve the JSON text in a single network round-trip,
/// parse it once and then return a map that contains the requested subset of
/// keys.  If a requested key is missing, or the JSON is malformed, a
/// `ServerError` will be raised to fail fast – this mirrors the behaviour of
/// the `Env` helpers elsewhere in the crate, where the application must not
/// start with an invalid configuration.
///
/// NOTE: the keys slice must contain **string literals** so that they carry a
/// `'static` lifetime.  This is trivially satisfied by the code generated by
/// the `define_ctx!` macro.
pub async fn load_secrets(
    keys: &[&'static str],
) -> Result<HashMap<&'static str, String>, ServerError> {
    // Lookup where the secrets live.
    let region_str = std::env::var(SECRETS_REGION).map_err(|_| {
        CriticalError::new(&format!("Missing env var `{}` required for secrets fetching", SECRETS_REGION))
    })?;
    let secrets_id = std::env::var(SECRETS_ID).map_err(|_| {
        CriticalError::new(&format!("Missing env var `{}` required for secrets fetching", SECRETS_ID))
    })?;

    // Configure the AWS SDK for the desired region.
    let region = Region::new(region_str.clone());
    let shared_config = aws_config::defaults(BehaviorVersion::v2025_01_17())
        .region(region)
        .load()
        .await;
    let client = Client::new(&shared_config);

    // Retrieve the JSON blob from Secrets Manager.
    let secrets_output = client
        .get_secret_value()
        .secret_id(&secrets_id)
        .send()
        .await
        .map_err(|e| {
            CriticalError::new(&format!(
                "Failed to fetch secrets JSON. id: {}, region: {} – {}",
                secrets_id, region_str, e
            ))
        })?;

    let secret_string = secrets_output.secret_string().ok_or_else(|| {
        CriticalError::new(&format!(
            "Secret value is empty or binary. SecretsId: {}; Region: {};",
            secrets_id, region_str
        ))
    })?;

    let secrets_json: HashMap<String, String> = serde_json::from_str(secret_string).map_err(|e| {
        CriticalError::new(&format!(
            "Invalid JSON in secret. id: {}, region: {}, error: {}",
            secrets_id, region_str, e
        ))
    })?;

    // Extract the requested subset.
    let mut subset = HashMap::new();
    for key in keys {
        let value = secrets_json.get(*key).ok_or_else(|| {
            CriticalError::new(&format!(
                "Missing secret key `{}` in secret id `{}`",
                key, secrets_id
            ))
        })?;
        subset.insert(*key, value.clone());
    }

    Ok(subset)
}